#use std;

let max:i32 = 1073741824;
fn checkrange(num:i32)->i32{
    while (num > max) {num = num - max;}
    while (num < 0) {num = num + max;}
    ret num;
}

fn mod(x:i32,y:i32)->i32{
    ret x-(x/y)*y;
}

fn reduce( kernelid:i32, x:i32, y:i32)->i32{
    if (kernelid == 0) {
        ret checkrange(x+y);
    }
    if (kernelid == 1) {
        let return_:i32 = 0;
        let i:i32 = 1;
        while (i < max){
            if (mod(x/i,2) == mod(y/i,2)) {
                return_ = return_ * 2;
            }
            else{
                return_ = return_ * 2 + 1;
            }
            i = i * 2;
        }
        ret return_;
    }
    if (kernelid == 2){
        if (x > y){ ret x;}
        else {ret y;}
    }
    if (kernelid == 3){
        let return_:i32 = 0;
        let i:i32 = 1;
        while (i < max){
            if ((mod(x/i,2) == 1) ||( mod(y/i,2) == 1)){
                return_ = return_ * 2 + 1;
            }
            else {
                return_ = return_ * 2;
            }
            i = i * 2;
        }
        ret return_;
    }
    if (kernelid == 4){
        let return_:i32 = 0;
        let i:i32 = 1;
        while (i < max){
            if ((mod(x/i,2) == 1) &&( mod(y/i,2) == 1)){
                return_ = return_ * 2 + 1;
            }
            else {
                return_ = return_ * 2;
            }
            i = i * 2;
        }
        ret return_;
    }
    ret 0;
}

fn getvalue(array[0]:i32,  n:i32,  m:i32,  x:i32,  y:i32)->i32{
    if ((x < 0) || (y < 0) || (x >= n) ||( y >= m)){ ret 0;}
    let tmp:i32 = x * m + y;
    ret array[tmp];
}

fn convn( kernelid:i32, input[0]:i32, output[0]:i32, n:i32, m:i32, c:i32)->i32{
    let i:i32 = 0;
    let j:i32= 0;
    let x:i32;
    let y:i32;
    let curr:i32;
    let true:i32 = 1;
    while (true == true){
        j = 0;
        while (true == true){
            curr = 0;
            x = i - c / 2;
            while (true == true){
                y = j - c / 2;
                while (true == true){
                    curr = reduce(kernelid, curr, getvalue(input, n, m, x, y));
                    y = y + 1;
                    if (y >= (j + c / 2)) {break;}
                }
                x = x + 1;
                if (x >= (i + c / 2)) {break;}
            }
            let tmp:i32=i * m + j;
            output[tmp] = curr;
            j = j + 1;
            if (j >= m) {break;}
        }
        i = i + 1;
        if (i >= n) {break;}
    }
    ret 0;
}

let a[10000000]:i32;
let  b[10000000]:i32;
let  kernelid[10000]:i32;

fn memmove( dst[0]:i32,  src[0]:i32,  n:i32){
    let i:i32 = 0;
    while (i < n){
        dst[i] = src[i];
        i = i + 1;
    }
}

fn main()->i32{
    let c:i32 = getint();
    let n:i32 = getint();
    let m:i32 = getint();
    let len:i32;
    len=getint();
    let ii:i32=0;
    while(ii<len){
        a[ii]=getint();
        ii=ii+1;
    }
    len=getint();
    ii=0;
    while(ii<len){
        kernelid[ii]=getint();
        ii=ii+1;
    }
    let task:i32 =len;
    
    timer_start(209);
    let i:i32 = 0;
    while (i < task){
        convn(kernelid[i], a, b, n, m, c);
        memmove(a, b, n * m);
        i = i + 1;
    }
    timer_stop(312);
    putarray(n * m, a);
    
    ret 0;
}