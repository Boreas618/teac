use std;

let max:i32 = 1073741824;
fn checkrange(num:i32) -> i32 {
    while num > max {
        num = num - max;
    }
    while num < 0 {
        num = num + max;
    }
    return num;
}

fn mod(x:i32,y:i32) -> i32 {
    return x-(x/y)*y;
}

fn reduce( kernelid:i32, x:i32, y:i32) -> i32 {
    if kernelid == 0 {
        return checkrange(x+y);
    }
    if kernelid == 1 {
        let ret_:i32 = 0;
        let i:i32 = 1;
        while i < max {
            if mod(x/i,2) == mod(y/i,2) {
                ret_ = ret_ * 2;
            }
            else{
                ret_ = ret_ * 2 + 1;
            }
            i = i * 2;
        }
        return ret_;
    }
    if kernelid == 2 {
        if x > y {
            return x;
        }
        else {
            return y;
        }
    }
    if kernelid == 3 {
        let ret_:i32 = 0;
        let i:i32 = 1;
        while i < max {
            if (mod(x/i,2) == 1) || ( mod(y/i,2) == 1) {
                ret_ = ret_ * 2 + 1;
            }
            else {
                ret_ = ret_ * 2;
            }
            i = i * 2;
        }
        return ret_;
    }
    if kernelid == 4 {
        let ret_:i32 = 0;
        let i:i32 = 1;
        while i < max {
            if (mod(x/i,2) == 1) && ( mod(y/i,2) == 1) {
                ret_ = ret_ * 2 + 1;
            }
            else {
                ret_ = ret_ * 2;
            }
            i = i * 2;
        }
        return ret_;
    }
    return 0;
}

fn getvalue(array: &[i32],  n:i32,  m:i32,  x:i32,  y:i32) -> i32 {
    if (x < 0) || (y < 0) || (x >= n) || ( y >= m) {
        return 0;
    }
    let tmp:i32 = x * m + y;
    return array[tmp];
}

fn convn( kernelid:i32, input: &[i32], output: &[i32], n:i32, m:i32, c:i32) -> i32 {
    let i:i32 = 0;
    let j:i32 = 0;
    let x:i32;
    let y:i32;
    let curr:i32;
    let true:i32 = 1;
    while true == true {
        j = 0;
        while true == true {
            curr = 0;
            x = i - c / 2;
            while true == true{
                y = j - c / 2;
                while true == true {
                    curr = reduce(kernelid, curr, getvalue(input, n, m, x, y));
                    y = y + 1;
                    if y >= (j + c / 2) {break;}
                }
                x = x + 1;
                if x >= (i + c / 2) {break;}
            }
            let tmp:i32 = i * m + j;
            output[tmp] = curr;
            j = j + 1;
            if j >= m {break;}
        }
        i = i + 1;
        if i >= n {break;}
    }
    return 0;
}

let a: [i32; 10000000];
let  b: [i32; 10000000];
let  kernelid: [i32; 10000];

fn memmove( dst: &[i32],  src: &[i32],  n:i32) {
    let i:i32 = 0;
    while i < n {
        dst[i] = src[i];
        i = i + 1;
    }
}

fn main() -> i32 {
    let c:i32 = std::getint();
    let n:i32 = std::getint();
    let m:i32 = std::getint();
    let len:i32;
    len = std::getint();
    let ii:i32 = 0;
    while ii < len {
        a[ii] = std::getint();
        ii = ii + 1;
    }
    len = std::getint();
    ii = 0;
    while ii < len {
        kernelid[ii] = std::getint();
        ii = ii + 1;
    }
    let task:i32 = len;
    
    std::timer_start(209);
    let i:i32 = 0;
    while i < task {
        convn(kernelid[i], a, b, n, m, c);
        memmove(a, b, n * m);
        i = i + 1;
    }
    std::timer_stop(312);
    std::putarray(n * m, a);
    
    return 0;
}
